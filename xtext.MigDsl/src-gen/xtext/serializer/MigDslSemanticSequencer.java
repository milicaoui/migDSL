/*
 * generated by Xtext 2.27.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import dsl.Column;
import dsl.DirectMapping;
import dsl.DslPackage;
import dsl.Field;
import dsl.ForeignKey;
import dsl.Migration;
import dsl.MngCollection;
import dsl.MongoDb;
import dsl.NestingList;
import dsl.NestingObject;
import dsl.NotNull;
import dsl.Options;
import dsl.PrimaryKey;
import dsl.RelationalDb;
import dsl.Table;
import dsl.Unique;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.services.MigDslGrammarAccess;

@SuppressWarnings("all")
public class MigDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MigDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case DslPackage.DIRECT_MAPPING:
				sequence_DirectMapping(context, (DirectMapping) semanticObject); 
				return; 
			case DslPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case DslPackage.FOREIGN_KEY:
				sequence_ForeignKey(context, (ForeignKey) semanticObject); 
				return; 
			case DslPackage.MIGRATION:
				sequence_Migration(context, (Migration) semanticObject); 
				return; 
			case DslPackage.MNG_COLLECTION:
				sequence_MngCollection(context, (MngCollection) semanticObject); 
				return; 
			case DslPackage.MONGO_DB:
				sequence_MongoDb(context, (MongoDb) semanticObject); 
				return; 
			case DslPackage.NESTING_LIST:
				sequence_NestingList(context, (NestingList) semanticObject); 
				return; 
			case DslPackage.NESTING_OBJECT:
				sequence_NestingObject(context, (NestingObject) semanticObject); 
				return; 
			case DslPackage.NOT_NULL:
				sequence_NotNull(context, (NotNull) semanticObject); 
				return; 
			case DslPackage.OPTIONS:
				sequence_Options(context, (Options) semanticObject); 
				return; 
			case DslPackage.PRIMARY_KEY:
				sequence_PrimaryKey(context, (PrimaryKey) semanticObject); 
				return; 
			case DslPackage.RELATIONAL_DB:
				sequence_RelationalDb(context, (RelationalDb) semanticObject); 
				return; 
			case DslPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case DslPackage.UNIQUE:
				sequence_Unique(context, (Unique) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.COLUMN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mapping returns DirectMapping
	 *     DirectMapping returns DirectMapping
	 *
	 * Constraint:
	 *     (name=EString? output=EString column=[Column|EString])
	 * </pre>
	 */
	protected void sequence_DirectMapping(ISerializationContext context, DirectMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (type=FieldType? name=EString (fields+=Field fields+=Field*)?)
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns ForeignKey
	 *     ForeignKey returns ForeignKey
	 *
	 * Constraint:
	 *     (name=EString referencing+=[Column|EString] referencing+=[Column|EString]* refrenced+=[Column|EString] refrenced+=[Column|EString]*)
	 * </pre>
	 */
	protected void sequence_ForeignKey(ISerializationContext context, ForeignKey semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Migration returns Migration
	 *
	 * Constraint:
	 *     (mappings+=Mapping* relationaldb=RelationalDb? mongodb=MongoDb? options=Options?)
	 * </pre>
	 */
	protected void sequence_Migration(ISerializationContext context, Migration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MngCollection returns MngCollection
	 *
	 * Constraint:
	 *     (name=EString (fields+=Field fields+=Field*)?)
	 * </pre>
	 */
	protected void sequence_MngCollection(ISerializationContext context, MngCollection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MongoDb returns MongoDb
	 *
	 * Constraint:
	 *     (
	 *         db=EString? 
	 *         host=EString? 
	 *         port=EString? 
	 *         username=EString? 
	 *         password=EString? 
	 *         (collections+=MngCollection collections+=MngCollection*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_MongoDb(ISerializationContext context, MongoDb semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mapping returns NestingList
	 *     NestingList returns NestingList
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         output=EString 
	 *         foreignkey=[ForeignKey|EString] 
	 *         (columns+=[Column|EString] columns+=[Column|EString]*)? 
	 *         (fields+=[Field|EString] fields+=[Field|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_NestingList(ISerializationContext context, NestingList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mapping returns NestingObject
	 *     NestingObject returns NestingObject
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         output=EString 
	 *         foreignkey=[ForeignKey|EString] 
	 *         (columns+=[Column|EString] columns+=[Column|EString]*)? 
	 *         (fields+=[Field|EString] fields+=[Field|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_NestingObject(ISerializationContext context, NestingObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns NotNull
	 *     NotNull returns NotNull
	 *
	 * Constraint:
	 *     (name=EString column=[Column|EString])
	 * </pre>
	 */
	protected void sequence_NotNull(ISerializationContext context, NotNull semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.NOT_NULL__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.NOT_NULL__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotNullAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNotNullAccess().getColumnColumnEStringParserRuleCall_3_0_1(), semanticObject.eGet(DslPackage.Literals.NOT_NULL__COLUMN, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Options returns Options
	 *
	 * Constraint:
	 *     (DataTypeMigration?='DataTypeMigration' AllowAdditionalFields?='AllowAdditionalFields')
	 * </pre>
	 */
	protected void sequence_Options(ISerializationContext context, Options semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.OPTIONS__DATA_TYPE_MIGRATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.OPTIONS__DATA_TYPE_MIGRATION));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.OPTIONS__ALLOW_ADDITIONAL_FIELDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.OPTIONS__ALLOW_ADDITIONAL_FIELDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionsAccess().getDataTypeMigrationDataTypeMigrationKeyword_2_0(), semanticObject.isDataTypeMigration());
		feeder.accept(grammarAccess.getOptionsAccess().getAllowAdditionalFieldsAllowAdditionalFieldsKeyword_3_0(), semanticObject.isAllowAdditionalFields());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns PrimaryKey
	 *     PrimaryKey returns PrimaryKey
	 *
	 * Constraint:
	 *     (name=EString keyColumns+=[Column|EString] keyColumns+=[Column|EString]*)
	 * </pre>
	 */
	protected void sequence_PrimaryKey(ISerializationContext context, PrimaryKey semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationalDb returns RelationalDb
	 *
	 * Constraint:
	 *     (
	 *         db=EString? 
	 *         host=EString? 
	 *         port=EString? 
	 *         username=EString? 
	 *         password=EString? 
	 *         tables+=Table 
	 *         tables+=Table* 
	 *         constraints+=Constraint 
	 *         constraints+=Constraint*
	 *     )
	 * </pre>
	 */
	protected void sequence_RelationalDb(ISerializationContext context, RelationalDb semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (name=EString (columns+=Column columns+=Column*)?)
	 * </pre>
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraint returns Unique
	 *     Unique returns Unique
	 *
	 * Constraint:
	 *     (name=EString uniqueColumns+=[Column|EString] uniqueColumns+=[Column|EString]*)
	 * </pre>
	 */
	protected void sequence_Unique(ISerializationContext context, Unique semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
